/*
    This file was auto-generated by the cmaj tool!
    cmajor.dev
*/

// Here's a very simple graph that plays a sine-wave to get you started..
graph MY_JX11  [[main]]
{
    input event std::midi::Message midiIn;  // [[ name: "MIDI input" ]];
    // output event std::midi::Message midiOut;
    output stream float out;

    // Demos volume/frequency parameters
    /*
    input gain.volume;
    input sine.frequencyIn;

    node sine = std::oscillators::Sine (float, 10);
    node gain = std::levels::SmoothedGain (float);

    connection sine -> gain.in;
    connection gain.out -> out;
    connection midiIn -> midiOut;
    */

    let voiceCount = 8;

    node
    {
        voices = Voice[voiceCount];
        voiceAllocator = std::voices::VoiceAllocator (voiceCount);
    }

    connection
    {
        // Convert the midi message to a our std::notes messages and forward to the voice allocator
        midiIn -> std::midi::MPEConverter -> voiceAllocator;

        // Plumb the voice allocator to the voices array
        voiceAllocator.voiceEventOut -> voices.eventIn;
        // voiceAllocator.voiceEventOut -> console;

        // Sum the voices audio out to the output
        voices -> out;
    }
}

graph Voice
{
    input event (std::notes::NoteOn, std::notes::NoteOff) eventIn;
    output stream float out;

    node
    {
        noteToFrequency = NoteToFrequency;
        envelope = std::envelopes::FixedASR (0.01f, 0.1f);
        oscillator = std::oscillators::Sine (float32);
        noise = noise_generator::Generator;
        blit_saw = blit_oscillator::NextSample;
    }

    connection
    {
        // eventIn -> noteToFrequency -> oscillator.frequencyIn;
        eventIn -> envelope.eventIn;
        eventIn -> noteToFrequency -> blit_saw.frequencyIn;
        // (envelope.gainOut * oscillator.out) -> out;
        // (envelope.gainOut * noise.out) -> out;
        (envelope.gainOut * blit_saw.out) -> out;
    }
}

// Determine the note frequency from the pitch (midi note)
processor NoteToFrequency
{
    input event std::notes::NoteOn eventIn;
    output event float32 frequencyOut;
    // output stream float32 frequencyOut;

    event eventIn (std::notes::NoteOn e)
    {
        frequencyOut <- std::notes::noteToFrequency (e.pitch);
        // frequencyOutStream <- std::notes::noteToFrequency (e.pitch);
    }
}

namespace noise_generator
{
    processor Generator 
    {
        output stream float out;

        int noiseSeed = 22222;

        void main()
        {
            loop
            {
                // Generate the next integer pseudorandom number
                noiseSeed = noiseSeed * 196314165 + 907633515;

                // Convert to a signed value
                int temp = int(noiseSeed >> 7) - 16777216;

                // Convert to a floating-point number between -1.0 and 1.0
                out <- float(temp) / 16777216.0f;
                advance();
            }
        }
    }
}

namespace blit_oscillator
{
    const float PI_OVER_4 = 0.7853981633974483f;
    const float PI = 3.1415926535897932f;
    const float TWO_PI = 6.2831853071795864f;

    processor NextSample
    {
        output stream float out;
        input event float32 frequencyIn;
        float32 inversePeriod;

        event frequencyIn(float32 value)
        {
            inversePeriod = (1 / value);
        }

        void main()
        {
            float period = 48000.0f * inversePeriod; // switching this to divide nukes audio buffer lol
            float amplitude = 1.0f;
            float inc = 0.0f;
            float phase = 0.0f;
            float phaseMax = 0.0f;
            float sin0 = 0.0f;
            float sin1 = 0.0f;
            float dsin = 0.0f;
            float dc = 0.0f;
            float saw = 0.0f;

            loop
            {
                float myOutput = 0.0f;

                phase += inc;

                if (phase <= PI_OVER_4) {
                    float halfPeriod = period / 2.0f;
                    phaseMax = my_std_lib::myFloor(0.5f + halfPeriod) - 0.5f;
                    dc = 0.5f * amplitude / phaseMax;
                    phaseMax *= PI;

                    inc = phaseMax / halfPeriod;
                    phase = -phase;

                    sin0 = amplitude * sin(phase);
                    sin1 = amplitude * sin(phase - inc);
                    dsin = 2.0f * cos(inc);

                    if (phase*phase > 1e-9) {
                        myOutput = sin0 / phase;
                    } else {
                        myOutput = amplitude;
                    }
                } else {
                    if (phase > phaseMax) {
                        phase = phaseMax + phaseMax - phase;
                        inc = -inc;
                    }
                    float sinp = dsin * sin0 - sin1;
                    sin1 = sin0;
                    sin0 = sinp;

                    myOutput = sinp / phase;
                }
                float sample = myOutput - dc;
                saw = saw * 0.997f + sample;
                out <- saw;
                // out <- (output - dc);
                advance();
            }
        }
    }
}

namespace my_std_lib
{
    float myFloor(float value)
    {
        // If the value is positive or zero, floor is just casting to int
        if (value >= 0.0f)
        {
            return float(int(value));
        }
        else
        {
            // If the value is negative and has a fractional part, subtract 1 after casting to int
            float flooredValue = float(int(value));
            return (flooredValue == value) ? flooredValue : (flooredValue - 1.0f);
        }
    }
}